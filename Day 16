online-store/
├─ server/
│ ├─ src/
│ │ ├─ config/db.js
│ │ ├─ models/User.js
│ │ ├─ models/Product.js
│ │ ├─ models/Order.js
│ │ ├─ middleware/auth.js
│ │ ├─ middleware/error.js
│ │ ├─ controllers/authCtrl.js
│ │ ├─ controllers/productCtrl.js
│ │ ├─ controllers/orderCtrl.js
│ │ ├─ controllers/uploadCtrl.js
│ │ ├─ routes/authRoutes.js
│ │ ├─ routes/productRoutes.js
│ │ ├─ routes/orderRoutes.js
│ │ ├─ routes/uploadRoutes.js
│ │ ├─ seed/seed.js
│ │ └─ server.js
│ ├─ .env.example
│ └─ package.json
└─ client/
├─ index.html
├─ src/
│ ├─ main.jsx
│ ├─ App.jsx
│ ├─ api/axios.js
│ ├─ store/index.js
│ ├─ features/authSlice.js
│ ├─ features/cartSlice.js
│ ├─ features/productSlice.js
│ ├─ features/orderSlice.js
│ ├─ components/Navbar.jsx
│ ├─ components/ProductCard.jsx
│ ├─ components/ProtectedRoute.jsx
│ ├─ pages/Home.jsx
│ ├─ pages/Product.jsx
│ ├─ pages/Cart.jsx
│ ├─ pages/Checkout.jsx
│ ├─ pages/Orders.jsx
│ ├─ pages/Login.jsx
│ └─ pages/Register.jsx
├─ styles/index.css
├─ tailwind.config.js
├─ postcss.config.js
└─ package.json


{
"name": "store-server",
"type": "module",
"scripts": {
"start": "node src/server.js",
"dev": "nodemon src/server.js",
"seed": "node src/seed/seed.js"
},
"dependencies": {
"bcryptjs": "^2.4.3",
"cors": "^2.8.5",
"dotenv": "^16.0.3",
"express": "^4.18.2",
"jsonwebtoken": "^9.0.0",
"mongoose": "^7.0.3",
"morgan": "^1.10.0",
"multer": "^1.4.5-lts.1"
},
"devDependencies": {
"nodemon": "^2.0.22"
}
}

PORT=5000
MONGO_URI=mongodb://127.0.0.1:27017/online_store
JWT_SECRET=change_me
CLIENT_URL=http://localhost:5173
UPLOAD_DIR=uploads

import mongoose from 'mongoose';


export const connectDB = async () => {
const uri = process.env.MONGO_URI;
if (!uri) throw new Error('MONGO_URI missing');
await mongoose.connect(uri, { autoIndex: true });
console.log('MongoDB connected:', mongoose.connection.host);
};

import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';


const userSchema = new mongoose.Schema({
name: { type: String, required: true },
email: { type: String, required: true, unique: true, lowercase: true },
password: { type: String, required: true },
isAdmin: { type: Boolean, default: false }
}, { timestamps: true });


userSchema.pre('save', async function(next) {
if (!this.isModified('password')) return next();
const salt = await bcrypt.genSalt(10);
this.password = await bcrypt.hash(this.password, salt);
next();
});


userSchema.methods.matchPassword = async function(plain) {
return bcrypt.compare(plain, this.password);
};


export default mongoose.model('User', userSchema);


import mongoose from 'mongoose';


const reviewSchema = new mongoose.Schema({
user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
name: String,
rating: { type: Number, min: 1, max: 5 },
comment: String
}, { timestamps: true });


const productSchema = new mongoose.Schema({
name: { type: String, required: true },
slug: { type: String, required: true, unique: true },
description: String,
brand: String,
category: String,
price: { type: Number, required: true },
countInStock: { type: Number, default: 0 },
image: String,
images: [String],
rating: { type: Number, default: 0 },
numReviews: { type: Number, default: 0 },
reviews: [reviewSchema]
}, { timestamps: true });


export default mongoose.model('Product', productSchema);


import mongoose from 'mongoose';


const orderItemSchema = new mongoose.Schema({
product: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
name: String,
qty: Number,
price: Number,
image: String
});


const orderSchema = new mongoose.Schema({
user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
orderItems: [orderItemSchema],
shippingAddress: {
fullName: String,
address: String,
city: String,
postalCode: String,
country: String
},
paymentMethod: { type: String, default: 'COD' },
itemsPrice: Number,
shippingPrice: Number,
taxPrice: Number,
totalPrice: Number,
isPaid: { type: Boolean, default: false },
paidAt: Date,
isDelivered: { type: Boolean, default: false },
deliveredAt: Date
}, { timestamps: true });


export default mongoose.model('Order', orderSchema);


import jwt from 'jsonwebtoken';
import User from '../models/User.js';


export const protect = async (req, res, next) => {
let token;
if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
try {
token = req.headers.authorization.split(' ')[1];
const decoded = jwt.verify(token, process.env.JWT_SECRET);
req.user = await User.findById(decoded.id).select('-password');
return next();
} catch (e) {
return res.status(401).json({ message: 'Not authorized, token failed' });
}
}
res.status(401).json({ message: 'Not authorized, no token' });
};


export const admin = (req, res, next) => {
if (req.user && req.user.isAdmin) return next();
res.status(403).json({ message: 'Admin only' });
};


export const notFound = (req, res, next) => {
const error = new Error(`Not Found - ${req.originalUrl}`);
res.status(404);
next(error);
};


export const errorHandler = (err, req, res, next) => {
const statusCode = res.statusCode && res.statusCode !== 200 ? res.statusCode : 500;
res.status(statusCode).json({
message: err.message || 'Server Error'
});
};


import jwt from 'jsonwebtoken';
import User from '../models/User.js';


const genToken = (id) => jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: '7d' });


export const register = async (req, res) => {
const { name, email, password } = req.body;
const exists = await User.findOne({ email });
if (exists) return res.status(400).json({ message: 'User already exists' });
const user = await User.create({ name, email, password });
res.status(201).json({
_id: user._id,
name: user.name,
email: user.email,
isAdmin: user.isAdmin,
token: genToken(user._id)
});
};


export const login = async (req, res) => {
const { email, password } = req.body;
const user = await User.findOne({ email });
if (!user || !(await user.matchPassword(password))) return res.status(401).json({ message: 'Invalid credentials' });
res.json({ _id: user._id, name: user.name, email: user.email, isAdmin: user.isAdmin, token: genToken(user._id) });
};


export const me = async (req, res) => {
res.json(req.user);
};


import Product from '../models/Product.js';


export const listProducts = async (req, res) => {
const page = Number(req.query.page) || 1;
const pageSize = Number(req.query.limit) || 12;
const keyword = req.query.q ? { name: { $regex: req.query.q, $options: 'i' } } : {};
const filter = { ...keyword };
const count = await Product.countDocuments(filter);
const products = await Product.find(filter)
.sort({ createdAt: -1 })
.skip(pageSize * (page - 1))
.limit(pageSize);
res.json({ products, page, pages: Math.ceil(count / pageSize), count });
};


export const getProduct = async (req, res) => {
const product = await Product.findOne({ slug: req.params.slug });
if (!product) return res.status(404).json({ message: 'Product not found' });
res.json(product);
};


export const createProduct = async (req, res) => {
const { name, description, brand, category, price, countInStock } = req.body;
const slug = name.toLowerCase().replace(/\s+/g, '-');
const product = await Product.create({ name, slug, description, brand, category, price, countInStock, image: req.file?.path });
res.status(201).json(product);
};


export const updateProduct = async (req, res) => {
const product = await Product.findById(req.params.id);
if (!product) return res.status(404).json({ message: 'Not found' });
Object.assign(product, req.body);
if (req.file?.path) product.image = req.file.path;
const saved = await product.save();
res.json(saved);
};


export const deleteProduct = async (req, res) => {
const product = await Product.findByIdAndDelete(req.params.id);
if (!product) return res.status(404).json({ message: 'Not found' });
res.json({ message: 'Deleted' });


import Order from '../models/Order.js';
import Product from '../models/Product.js';


export const createOrder = async (req, res) => {
const { orderItems, shippingAddress, paymentMethod } = req.body;
if (!orderItems || orderItems.length === 0) return res.status(400).json({ message: 'No items' });


// calculate prices from DB to avoid tampering
const items = await Promise.all(orderItems.map(async (i) => {
const p = await Product.findById(i.product);
return { ...i, price: p.price, name: p.name, image: p.image };
}));
const itemsPrice = items.reduce((a, c) => a + c.price * c.qty, 0);
const shippingPrice = itemsPrice > 999 ? 0 : 99;
const taxPrice = Math.round(itemsPrice * 0.18);
const totalPrice = itemsPrice + shippingPrice + taxPrice;


const order = await Order.create({
user: req.user._id,
orderItems: items,
shippingAddress,
paymentMethod,
itemsPrice,
shippingPrice,
taxPrice,
totalPrice,
isPaid: true,
paidAt: new Date()
});
res.status(201).json(order);
};


export const myOrders = async (req, res) => {
const orders = await Order.find({ user: req.user._id }).sort({ createdAt: -1 });
res.json(orders);
};


export const listOrders = async (req, res) => {
const orders = await Order.find().populate('user', 'name email').sort({ createdAt: -1 });
res.json(orders);
};


export const mar
