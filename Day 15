/fullstack-auth
/backend
package.json
tsconfig.json
prisma/schema.prisma
.env
src/
app.ts
server.ts
prisma.ts
routes/
auth.ts
notes.ts
controllers/
authController.ts
notesController.ts
services/
authService.ts
middleware/
auth.ts
utils/
validators.ts
/frontend
package.json
vite.config.ts
tailwind.config.cjs
postcss.config.cjs
tsconfig.json
src/
main.tsx
App.tsx
index.css
api/
client.ts
auth.ts
notes.ts
hooks/
useAuth.ts
pages/
Login.tsx
Register.tsx
Dashboard.tsx
NoteEditor.tsx

{
"name": "auth-backend",
"version": "1.0.0",
"private": true,
"scripts": {
"dev": "ts-node-dev --respawn --transpile-only src/server.ts",
"build": "tsc",
"start": "node dist/server.js",
"prisma:generate": "prisma generate",
"prisma:migrate": "prisma migrate dev"
},
"dependencies": {
"bcrypt": "^5.1.0",
"cookie-parser": "^1.4.6",
"cors": "^2.8.5",
"dotenv": "^16.0.0",
"express": "^4.18.2",
"express-rate-limit": "^6.7.0",
"helmet": "^7.0.0",
"jsonwebtoken": "^9.0.0",
"prisma": "^5.0.0",
"zod": "^3.21.4"
},
"devDependencies": {
"@types/bcrypt": "^5.0.0",
"@types/cookie-parser": "^1.4.3",
"@types/cors": "^2.8.12",
"@types/express": "^4.17.17",
"@types/jsonwebtoken": "^9.0.2",
"ts-node-dev": "^2.0.0",
"typescript": "^5.3.0"
}
}
{
"compilerOptions": {
"target": "ES2022",
"module": "CommonJS",
"moduleResolution": "node",
"outDir": "dist",
"rootDir": "src",
"strict": true,
"esModuleInterop": true,
"skipLibCheck": true,
"forceConsistentCasingInFileNames": true,
"resolveJsonModule": true
}
}

generator client {
provider = "prisma-client-js"
}


datasource db {
provider = "postgresql"
url = env("DATABASE_URL")
}


model User {
id String @id @default(cuid())
email String @unique
name String?
passwordHash String
sessions Session[]
notes Note[]
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt
}


model Session {
id String @id @default(cuid())
user User @relation(fields: [userId], references: [id])
userId String
token String @unique
expiresAt DateTime
createdAt DateTime @default(now())
revoked Boolean @default(false)
}


model Note {
id String @id @default(cuid())
user User @relation(fields: [userId], references: [id])
userId String
title String
content String
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt
}
import { PrismaClient } from '@prisma/client';


const prisma = new PrismaClient();
export default prisma;

import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import cookieParser from 'cookie-parser';
import authRoutes from './routes/auth';
import notesRoutes from './routes/notes';


const app = express();
app.use(helmet());
app.use(express.json());
app.use(cookieParser());


app.use(cors({
origin: 'http://localhost:5173',
credentials: true,
}));


app.use('/api/auth', authRoutes);
app.use('/api/notes', notesRoutes);


app.get('/', (req, res) => res.json({ ok: true }));


export default app;
components/
ProtectedRoute.tsx
Nav.tsx

import 'dotenv/config';
import app from './app';
import prisma from './prisma';


const PORT = process.env.PORT || 4000;


async function start() {
try {
await prisma.$connect();
app.listen(PORT, () => console.log(`Server running on http://localhost:${PORT}`));
} catch (err) {
console.error('Failed to start', err);
process.exit(1);
}
}


start();


import { z } from 'zod';


export const registerSchema = z.object({
name: z.string().min(2).max(60),
email: z.string().email(),
password: z.string().min(8).max(128),
});


export const loginSchema = z.object({
email: z.string().email(),
password: z.string().min(1),
});


export const noteSchema = z.object({
title: z.string().min(1),
content: z.string().optional(),
});

import prisma from '../prisma';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';


const ACCESS_SECRET = process.env.JWT_ACCESS_SECRET!;
const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;
const ACCESS_EXPIRES = process.env.ACCESS_TOKEN_EXPIRES_IN || '15m';
const REFRESH_DAYS = Number(process.env.REFRESH_TOKEN_EXPIRES_DAYS || '30');


export async function createUser(name: string, email: string, password: string) {
const hash = await bcrypt.hash(password, 12);
return prisma.user.create({ data: { name, email, passwordHash: hash } });
}


export async function verifyPassword(password: string, user: any) {
return bcrypt.compare(password, user.passwordHash);
}


export function signAccessToken(user: any) {
return jwt.sign({ sub: user.id, email: user.email }, ACCESS_SECRET, { expiresIn: ACCESS_EXPIRES });
}


export function verifyAccessToken(token: string) {
return jwt.verify(token, ACCESS_SECRET) as any;
}


export function signRefreshToken(user: any) {
return jwt.sign({ sub: user.id }, REFRESH_SECRET, { expiresIn: `${REFRESH_DAYS}d` });
}


export function verifyRefreshToken(token: string) {
return jwt.verify(token, REFRESH_SECRET) as any;
}


export async function createRefreshSession(userId: string, token: string) {
const expiresAt = new Date(Date.now() + REFRESH_DAYS * 24 * 60 * 60 * 1000);
return prisma.session.create({ data: { userId, token, expiresAt } });
}


export async function revokeRefreshToken(token: string) {
await prisma.session.updateMany({ where: { token }, data: { revoked: true } });
}


export async function rotateRefreshToken(oldToken: string, newToken: string) {
// revoke old and create new
await prisma.session.updateMany({ where: { token: oldToken }, data: { revoked: true } });
return prisma.session.create({ data: { userId: '', token: newToken, expiresAt: new Date(Date.now() + REFRESH_DAYS * 24 * 60 * 60 * 1000) } });
}


import { Request, Response, NextFunction } from 'express';
import { verifyAccessToken } from '../services/authService';


export interface AuthRequest extends Request {
user?: { sub: string; email?: string };
}


export function authMiddleware(req: AuthRequest, res: Response, next: NextFunction) {
const auth = req.headers.authorization;
if (!auth?.startsWith('Bearer ')) return res.status(401).json({ message: 'Missing token' });
const token = auth.slice(7);
try {
const payload = verifyAccessToken(token);
req.user = payload;
next();
} catch (err) {
return res.status(401).json({ message: 'Invalid token' });
}
}

import { Router } from 'express';
import { register, login, refresh, logout, me } from '../controllers/authController';


const router = Router();


router.post('/register', register);
router.post('/login', login);
router.post('/refresh', refresh);
router.post('/logout', logout);
router.get('/me', me);


export default router;

import { Request, Response } from 'express';
import prisma from '../prisma';
import { registerSchema, loginSchema } from '../utils/validators';
import {
createUser,
verifyPassword,
signAccessToken,
signRefreshToken,
createRefreshSession,
verifyRefreshToken,
revokeRefreshToken,
} from '../services/authService';


const COOKIE_NAME = 'refresh_token';


export async function register(req: Request, res: Response) {
try {
const { name, email, password } = registerSchema.parse(req.body);
const existing = await prisma.user.findUnique({ where: { email } });
if (existing) return res.status(409).json({ message: 'Email already used' });


const user = await createUser(name, email, password);


const accessToken = signAccessToken(user);
const refreshToken = signRefreshToken(user);
await createRefreshSession(user.id, refreshToken);


res.cookie(COOKIE_NAME, refreshToken, {
httpOnly: true,
secure: process.env.NODE_ENV === 'production',
sameSite: 'strict',
path: '/api/auth/refresh',
maxAge: 1000 * 60 * 60 * 24 * Number(process.env.REFRESH_TOKEN_EXPIRES_DAYS || 30),
});


return res.status(201).json({ user: { id: user.id, email: user.email, name: user.name }, accessToken });
} catch (err: any) {
if (err?.issues) return res.status(400).json({ message: 'Validation error', errors: err.issues });
console.error(err);
return res.status(500).json({ mes
