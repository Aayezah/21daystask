/**
 * Auth API — Node.js + Express + MongoDB (Mongoose)
 * Endpoints:
 *   POST   /api/auth/register   { name, email, password }
 *   POST   /api/auth/login      { email, password }
 *   GET    /api/auth/me         (requires Bearer token)
 *
 * Quick start:
 *   1) Create .env with the sample below
 *   2) npm init -y
 *      npm i express mongoose bcrypt jsonwebtoken cors helmet morgan zod express-rate-limit dotenv
 *   3) node server.js
 *
 * Sample .env
 *   PORT=4000
 *   MONGODB_URI=mongodb://127.0.0.1:27017/auth_demo
 *   JWT_SECRET=superlongrandomsecret_change_me
 *   JWT_EXPIRES_IN=7d
 *
 * cURL demo:
 *   Register:
 *     curl -s -X POST http://localhost:4000/api/auth/register \
 *       -H "Content-Type: application/json" \
 *       -d '{"name":"Aayezah","email":"a@example.com","password":"Passw0rd!"}' | jq
 *   Login:
 *     curl -s -X POST http://localhost:4000/api/auth/login \
 *       -H "Content-Type: application/json" \
 *       -d '{"email":"a@example.com","password":"Passw0rd!"}' | jq
 *   Me:
 *     curl -s http://localhost:4000/api/auth/me -H "Authorization: Bearer <TOKEN>" | jq
 */

require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const { z } = require('zod');
const rateLimit = require('express-rate-limit');

// --- Config ---
const app = express();
app.use(express.json({ limit: '10kb' }));
app.use(cors());
app.use(helmet());
app.use(morgan('dev'));

const PORT = process.env.PORT || 4000;
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://127.0.0.1:27017/auth_demo';
const JWT_SECRET = process.env.JWT_SECRET || 'dev_only_secret_change_me';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';

// --- DB ---
mongoose
  .connect(MONGODB_URI)
  .then(() => console.log('✅ MongoDB connected'))
  .catch((err) => {
    console.error('❌ MongoDB connection error:', err.message);
    process.exit(1);
  });

// --- User Model ---
const userSchema = new mongoose.Schema(
  {
    name: { type: String, required: true, trim: true, minlength: 2, maxlength: 60 },
    email: { type: String, required: true, unique: true, lowercase: true, trim: true },
    passwordHash: { type: String, required: true },
    // for demo, you can add roles, verified flags, etc.
  },
  { timestamps: true }
);

userSchema.methods.toPublicJSON = function () {
  return {
    id: this._id,
    name: this.name,
    email: this.email,
    createdAt: this.createdAt,
    updatedAt: this.updatedAt,
  };
};

const User = mongoose.model('User', userSchema);

// --- Validation Schemas (Zod) ---
const registerSchema = z.object({
  name: z.string().min(2).max(60),
  email: z.string().email(),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .max(128)
    .regex(/(?=.*[a-z])/, 'must include a lowercase letter')
    .regex(/(?=.*[A-Z])/, 'must include an uppercase letter')
    .regex(/(?=.*\d)/, 'must include a number'),
});

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

// --- Helpers ---
const issueToken = (user) =>
  jwt.sign({ sub: user._id.toString(), email: user.email }, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
  });

const authMiddleware = (req, res, next) => {
  const auth = req.headers.authorization || '';
  const token = auth.startsWith('Bearer ') ? auth.slice(7) : null;
  if (!token) return res.status(401).json({ message: 'Missing Bearer token' });
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload; // { sub, email, iat, exp }
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Invalid or expired token' });
  }
};

// Apply gentle rate limiting to auth routes
const authLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 20,
  standardHeaders: true,
  legacyHeaders: false,
});
app.use('/api/auth', authLimiter);

// --- Routes ---
app.post('/api/auth/register', async (req, res) => {
  try {
    const { name, email, password } = registerSchema.parse(req.body);

    const exists = await User.findOne({ email });
    if (exists) return res.status(409).json({ message: 'Email already registered' });

    const passwordHash = await bcrypt.hash(password, 12);
    const user = await User.create({ name, email, passwordHash });

    const token = issueToken(user);
    return res.status(201).json({ user: user.toPublicJSON(), token });
  } catch (err) {
    if (err?.issues) {
      // zod validation error
      return res.status(400).json({ message: 'Validation failed', errors: err.issues });
    }
    console.error('Register error:', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = loginSchema.parse(req.body);

    const user = await User.findOne({ email });
    if (!user) return res.status(401).json({ message: 'Invalid credentials' });

    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(401).json({ message: 'Invalid credentials' });

    const token = issueToken(user);
    return res.json({ user: user.toPublicJSON(), token });
  } catch (err) {
    if (err?.issues) {
      return res.status(400).json({ message: 'Validation failed', errors: err.issues });
    }
    console.error('Login error:', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

app.get('/api/auth/me', authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.user.sub);
    if (!user) return res.status(404).json({ message: 'User not found' });
    return res.json({ user: user.toPublicJSON() });
  } catch (err) {
    console.error('Me error:', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// --- 404 + Error handlers ---
app.use((req, res) => {
  res.status(404).json({ message: 'Route not found' });
});

// Centralized error handler (as a safety net)
// eslint-disable-next-line no-unused-vars
app.use((err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(500).json({ message: 'Unexpected server error' });
});

app.listen(PORT, () => console.log(`🚀 Auth API listening on http://localhost:${PORT}`));

/**
 * Notes:
 * - Passwords are hashed with bcrypt (12 rounds). Never store plaintext passwords.
 * - JWT is signed with HS256. Keep JWT_SECRET long & random. Rotate periodically.
 * - Adjust CORS for your frontend origin (e.g., app.use(cors({ origin: 'http://localhost:5173', credentials: true }))).
 * - For refresh tokens or session-based auth, add a /refresh endpoint and store refresh tokens (DB/Redis/cookie).
 * - For production behind a proxy (e.g., Render/Heroku/Nginx), consider app.set('trust proxy', 1).
 * - To add email verification or password reset, store tokens with expiries and send via a mail provider.
 */
